\documentclass{article}

\usepackage{url}
\usepackage{fullpage}
\usepackage{color}

\usepackage{xspace}

\usepackage{stmaryrd}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\newcommand{\BIND}{\mathbin{\texttt{>\!>\!=}}}
\newcommand{\BETWEEN}{\leftrightarrow}
\newcommand{\texteq}{\mathrel{\texttt{==}}}
\newcommand{\APPEND}{\mathbin{\texttt{++}}}

\input{macros}

\title{An Embedded DSL for Bidirectionalization}
\author{Kazutaka Matsuda \and Meng Wang \and \dots}

\begin{document}
\maketitle

%% \section{Introduction}
%% \todo{General explanation of bidirectionalization}

%% To explain what problem we target, let us consider an XHTML
%% transformation that extracts all the anchor tags and suppose that we
%% want to bidirectionalize it so that we can reflect updates on urls and
%% linked texts to corresponding elements on the original document. We
%% assume that XML documents are expressed by the following datatype for
%% generic rose trees and the following label type.
%% \[
%% \bb
%%  \key{data}~\mi{Tree}~\alpha = \mi{Node}~\alpha~[\mi{Tree}]\\
%%  \key{data}~\mi{Label} = \mi{Elem}~\mi{String} \mid \mi{Text}~\mi{String}
%% \ee
%% \]
%% For example, an XML document like 
%% \[
%%  \texttt{<p>}\texttt{see <a href="www">this</a>}\texttt{</p>}
%% \]
%% is represented as below in the datatype.
%% \[
%% \bb
%%  \mi{Node}~(\mi{Elem}~\texttt{"p"})~[\\
%% \quad 
%%  \bb
%%    \mi{Node}~(\mi{Text}~\texttt{"see "})~[], \\
%%    \mi{Node}~(\mi{Elem}~\texttt{"a"})~ [ 
%%      \mi{Node}~(\mi{Elem}~\texttt{"@href"})~ [
%%          \mi{Node}~(\mi{Text}~\texttt{"www"})~ []
%%      ],
%%      \mi{Node}~(\mi{Text}~\texttt{"this"})~ []
%%    ]]
%% \ee
%% \ee
%% \]

%% A forward transformation 


%% So far, several bidirectionalization methods have been proposed~\cite{}.
%% However, to the best of our knowledge none of the existing methods 



\section{Idea}
In our embedded DSL, once one writes a function with a \emph{polymorphic} such as 
\[
 h :: \forall \alpha \mu. (\mi{PackM}~\mi{Label}~\alpha~\mu)
  \Rightarrow \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha)
\]
then the one can obtain the forward and backward transformations of it by using 
$\mi{fwd}$ and $\mi{bwd}$, as:
\[
\bb
  \mi{fwd}~h :: \mi{Tree}~\mi{Label} \to \mi{Tree}~\mi{Label}\\
  \mi{bwd}~h :: \mi{Tree}~\mi{Label} \to \mi{Tree}~\mi{Label} \to \mi{Tree}~\mi{Label}
\ee
\]
In the following, we roughly explains the idea behind our EDSL. 

The class $\mi{PackM}$ plays an important role in our EDSL, 
which is defined as below.\footnote{We actually use functional dependencies 
in $\mi{Pack}$ and $\mi{PackM}$ for convenience and some codes in the paper do not pass Haskell's type check without them. We ignore them for a while because they are the point of our paper.}
\[
\bb
 \key{class}~\mi{Pack}~\gamma~\alpha~\key{where} \\
 \quad \mi{new} :: \gamma \to \alpha \\
 \key{class}~(\mi{Pack}~\gamma~\alpha, \mi{Monad}~\mu) \Rightarrow \mi{PackM}~\gamma~\alpha~\mu~\key{where}\\
 \quad \mi{liftO} :: \mi{Eq}~\beta \Rightarrow ([\gamma] \to \beta) \to ([\alpha] \to \mu~\beta)
\ee
\]
Very roughly speaking, $\mi{PackM}~\gamma~\alpha~\mu$ provides a way
to abstract a concrete type $\gamma$ by a polymorphic type $\alpha$.
Here, $\mi{new}$ supports creation of a value of the abstract type and 
$\mi{liftO}$ lifts ``observations'' on the concrete level to 
the abstract level with recording its result by $\mu$. 
The recorded observation history is the key to our bidirectionalization;
by preserving the history, we can guarantee the correctness of our bidirectionalization. That is, the history is ``complement''. 


%% For simplicity, we consider only the equality test on the datatype 
%% we focus on. The idea is to write a function with a \emph{polymorphic} type
%% as follows. 
%% \[
%% \mi{links} :: \forall \alpha \mu. (\mi{Pack}~\mi{Label}~\alpha, \mi{EqO}~\alpha~\mu) \Rightarrow 
%%  \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha)
%% \]
%% Intuitively, type classes $\mi{Pack}$ and $\mi{Label}$, and a monad $\mi{View}$
%% can be read as follows:
%% \begin{itemize}
%%  \item $\mi{Pack}~\mi{Label}~\alpha$ means that we abstract $\mi{Label}$ as 
%%    a polymorphic type $\alpha$ in the transformation. 
%%  \item $\mi{EqO}~\alpha~\mu$ means that we can compare $\alpha$ type values 
%%    and its comparison results are recorded by a monad $\mu$.
%% \end{itemize}
%% More precisely, $\mi{Pack}$ provides a method $\mi{new}$ to construct a new label as follows.\footnote{We have to add some functional dependencies to $\mi{Pack}$ and $\mi{EqO}$ to make the codes in the paper to pass the type check. Since doing so complicates the codes, we ignore it for a while. }
%% \[
%% \bb
%%  \key{class}~\mi{Pack}~\gamma~\alpha %\mid \alpha \to \gamma 
%%   ~\key{where}\\
%%   \quad \mi{new} :: \gamma \to \alpha 
%% \ee
%% \]
%% The class $\mi{EqO}$ provides a method for equivalence check. 
%% \[
%%  \bb 
%%   \key{class}~\mi{Moand}~\mu \Rightarrow \mi{EqO}~\alpha~\mu~%\mid~\alpha \to \eta, \eta \to \alpha~
%%    \key{where} \\
%%   \quad \mi{eq} :: \alpha \to \alpha \to \mu~\mi{Bool} \\
%% %  \quad \mi{checkUpd} :: (\alpha \to \alpha) \to \eta \to \mi{Bool}
%%  \ee
%% \]

%% In the transformation, we use two instances of $\mi{Monad}$ for $\mu$. 
%% The one is $\mi{I}$ defined by:
%% \[
%% \bb
%%  \key{newtype}~\mi{I}~\alpha = \mi{Identity}~\alpha\\
%%  \key{instance}~\mi{Monad}~\mi{Identity}~\key{where} \\
%%  \quad \bb
%%   \mi{return} = \mi{I} \\
%%   { (\mi{I}~x) \BIND f } = f~x\\
%%  \ee\\
%% \ee
%% \]
%% The other is $\mi{W}$, which is essentially a pair, defined by:
%% \[
%% \bb
%%  \key{newtype}~\mi{W}~\eta~\alpha = \mi{W}~\alpha~[\eta]\\
%%  \key{instance}~\mi{Monad}~(\mi{W}~\eta)~\key{where} \\
%%  \quad \bb
%%   \mi{return}~x= \mi{W}~x~[] \\
%%   { m \BIND f } = 
%%     \bbt
%%       \key{let}~\bbt \mi{W}~(x,h_1) = m \\
%%                      \mi{W}~(y,h_2) = f~x \ee\\
%%       \key{in}~\mi{W}~(y,h_1 \APPEND h_2)
%%     \ee
%%  \ee\\
%% \ee
%% \]
%% We also use the following function $\mi{tell}$.
%% \[
%%   \mi{tell}~w = \mi{W}~()~[w]
%% \]
%% Accordingly, we also provide the following two instances of $\mi{EqO}$.
%% \[
%%   \bb
%%    \key{instance}~\mi{Eq}~\alpha \Rightarrow \mi{EqO}~\alpha~\mi{Identity}~\key{where} \\
%%    \quad \mi{eq}~x~y = \mi{return}~(x \texteq y) 
%%   \ee 
%% \]
%% \[
%%   \bb
%%    \key{instance}~\mi{Eq}~\alpha \Rightarrow \mi{EqO}~\alpha~(\mi{Writer}~\mi{ObsEq}~\alpha)\key{where} \\
%%    \quad \mi{eq}~x~y = 
%%      \key{do}~\bbt
%%                 \mi{tell}~(\mi{ObsEq}~x~y~(x \texteq y))\\
%%                 \mi{return}~(x \texteq y) 
%%               \ee\\
%%   \ee 
%% \]
%% Here, $\mi{ObsEq}$ is a datatype to record an equivalence check result, defined by:
%% \[
%%   \key{data}~\mi{ObsEq}~\alpha = \mi{ObsEq}~\alpha~\alpha~\mi{Bool}
%% \]

%% Beforehand showing how we can obtain the forward and a backward
%% transformation from the kind of polymorphic function, we introduce two
%% instances of $\mi{WeakWriter}$. The one is $\mi{CC}~\eta$, the
%% flipped version of $\mi{Const}$, that completely ignore $\eta$,
%% defined by:
%% \[
%% \bb
%%  \key{newtype}~\mi{CC}~\eta~\alpha = \mi{CC}~\alpha\\
%%  \key{instance}~\mi{Monad}~(\mi{CC}~\eta)~\key{where} \\
%%  \quad \bb
%%   \mi{return} = \mi{CC} \\
%%   { (\mi{CC}~x) \BIND f } = f~x\\
%%  \ee\\
%%  \key{instance}~\mi{WeakWriter}~\eta~(\mi{CC}~\eta)~\key{where} \\
%%  \quad \bb
%%   \mi{tell}~x = \mi{return}~()
%%  \ee
%% \ee
%% \]
%% The other is $\mi{WW}~\eta$ that remembers the history by using list, which 
%% would be a simplified version of $\mi{Writer}$, defined by:
%% \[
%% \bb
%%  \key{newtype}~\mi{WW}~\eta~\alpha = \mi{WW}~(\alpha,[\eta])\\
%%  \key{instance}~\mi{Monad}~(\mi{WW}~\eta)~\key{where} \\
%%  \quad \bb
%%   \mi{return}~x= \mi{WW}~(x,[]) \\
%%   { m \BIND f } = 
%%     \bbt
%%       \key{let}~\bbt \mi{WW}~(x,h_1) = m \\
%%                      \mi{WW}~(y,h_2) = f~x \ee\\
%%       \key{in}~\mi{WW}~(y,h_1 \APPEND h_2)
%%     \ee
%%  \ee\\
%%  \key{instance}~\mi{WeakWriter}~\eta~(\mi{WW}~\eta)~\key{where} \\
%%  \quad \bb
%%   \mi{tell}~w = \mi{WW}~((),[w])
%%  \ee
%% \ee
%% \]

%% We also introduce the following instance of $\mi{EqO}$.
%% \[
%%  \bb
%%    \key{instance}~\mi{Eq}~\alpha \Rightarrow \mi{EqO}~\alpha~(\mi{ObsEq}~\alpha)~\key{where} \\
%%    \quad \mi{eq}~x~y = 
%%      \key{do}~\bbt
%%                 \mi{tell}~(\mi{ObsEq}~x~y~(x \texteq y))\\
%%                 \mi{return}~(x \texteq y) 
%%               \ee\\
%%    \quad \mi{check}~u~(\mi{ObsEq}~x~y~b) =
%%              (u~x \texteq u~y) \texteq b 
%%  \ee
%% \]

To define the corresponding forward transformation, we prepare the following identity monad $I$. (Note that, although it suffices to use $\mi{Identity}$ in Haskell, we use $I$ instead of brevity.)
\[
\bb
 \key{newtype}~I~\alpha = I~\alpha\\
 \key{instance}~\mi{Monad}~I~\key{where} \\
 \quad \mi{return} = I \\
 \quad (I~x) \BIND f = I~(f~x) 
\ee
\]
Then, the forward transformation can be achieved directly by instantiating $\alpha$ as $\gamma$ and $\mu$ as the identity monad $I$.
\[
\]
\[
\bb
\mi{fwd} :: \mi{Eq}~\gamma \Rightarrow (
 \forall \alpha \mu. (\mi{PackM}~\gamma~\alpha~\mu) \Rightarrow 
 \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha))
 \to \mi{Tree}~\gamma \to \mi{Tree}~\gamma\\
\mi{fwd}~h = \lambda s. 
    \key{let}~\mi{I}~v = h~s~\key{in}~v 
\ee
\]
The following instance of $\mi{PackM}$ is used in the computation.
\[
\bb
 \key{instance}~\mi{Pack}~\gamma~\gamma~\key{where} \\
 \quad \mi{new} = \mi{id} \\
 \key{instance}~\mi{PackM}~\gamma~\gamma~\mi{I}~\key{where}\\
 \quad \mi{liftO}~\mi{p}~x = \mi{I}~(p~x) 
\ee 
\]
Clearly, the instance does nothing special. So, in this sense,
$\mi{fwd}~h$ simply execute $h$.



%% In the transformation, $\alpha$ and $\mu$ are instantiated as $\gamma$ and $\mi{I}$, respectively. The following 
%% instance of $\mi{Pack}$ is used\footnote{This definition would cause a problem in Haskell's type inference. However, we ignore such a type inference issue for a while.}.
%% \[
%% \bb
%%   \key{instance}~\mi{Pack}~\gamma~\gamma~\key{where} \\
%%   \quad \mi{new} = \mi{id}
%% \\
%%   \key{instance}~\mi{EqO}~\mi{Label}~\key{where} \\
%%   \quad \mi{eq}~x~y = \key{do}~ 
%%      \bbt \mi{tell}~(\mi{Obs}~x~y~(x \texteq y))\\
%%      \mi{return}~(x \texteq y)\ee \\                              
%%  \ee
%% \]
%Here, $\mi{Obs}$ is a datatype to record a result of equivalence check. 

A backward transformation is a bit complicated. The basic idea of our
construction basically follows the previous work. We track pointers by
using the polymorphic function. The main difference from the previous
work is that we keep track the equivalence check history by
instantiating $\mu$ by some ``writer'' monad as ``complement''. 
Concretely, we use the following monad $W$. (Again, note that, although it suffices to use $\mi{Writer}$ in Haskell, we use $W$ instead for brevity.)
\[
\bb
 \key{newtype}~W~\eta~\alpha = W~(\alpha,\eta)\\
 \key{instance}~\mi{Monoid}~w \Rightarrow \mi{Monad}~(W~\eta)~\key{where} \\
 \quad \mi{return}~x = W~(x,\mi{mempty}) \\
 \quad (W~(x,w_1)) \BIND f =
    \key{let}~(y,w_2) = f~x~\key{in}~W~(y,\mi{mappend}~w_1~w_2)\\
 \mi{tell}~w = W~((),w)\\
\ee
\] 
The
correctness of the derived backward transformation with respect to the
forward transformation is guaranteed by keeping the history
consistent. 
Since we have record arbitrary observations such as $\mi{(==)}$ and $\mi{compare}$ by $\mi{liftO}$, 
the recorded value must be able to store various observation results such as $\mi{Bool}$ and $\mi{Ordering}$. This is achieved by using existentially quantified datatype. 
\[
\key{data}~\mi{Result}~\alpha = \forall \beta.\mi{Eq}~\beta \Rightarrow \mi{Result}~([\alpha]\to \beta)~[\alpha]~\beta
\]
Note that, while using $\forall$ instead of $\exists$, the type is identical to $\exists \beta.(\beta \to \beta \to \mi{Bool}) \times ([\alpha] \to \beta) \times  [\alpha] \times \beta$.
We also provides a function that checks if an observation result is consistent or not. 
\[
 \mi{check}~(\mi{Result}~p~x~r) = p~x \texteq r 
\]
A subtle difference from the previous work is that we keep a pointer with an element 
instead of keeping pointer only. 
This is handy for us to implement $\mi{new}$.
Concretely, we use the following datatype for an element with its pointer. 
\[
 \key{data}~\mi{Loc}~\alpha = \mi{Loc}~\alpha~(\mi{Maybe}~\mi{Int})
\]
We also prepare the following function for convenience. 
\[
 \mi{body}~(\mi{Loc}~a~\dontcare) = a
\]
Then, the following is the definition $\mi{bwd}$ that derives 
a backward transformation from a polymorphic transformation. 
\[
 \bb
\mi{bwd} :: 
(
 \forall \alpha \mu. (\mi{PackM}~\gamma~\alpha~\mu) \Rightarrow 
 \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha))
 \to \mi{Tree}~\gamma \to \mi{Tree}~\gamma \to \mi{Tree}~\gamma \\
 \mi{bwd}~h = \lambda s.\lambda v. 

   \bbt \key{let}~ \bbt \mi{xsrc} = \mi{assignIDs}~s \\
                        W~(\mi{xview},\mi{hist}) = h~\mi{xsrc} \\
                        \mi{upd}  = \mi{matchViews}~v~\mi{xview} \\
                   \ee\\
        \key{in}~\bbt
           \key{if}~\mi{checkHistory}~\mi{upd}~\mi{hist}~\key{then}\\
           \quad \mi{fmap}~(\mi{fst} \circ \mi{update}~\mi{upd})~\mi{xview}\\
           \key{else}\\
           \quad \mi{error}~\texttt{"Invariants are Violated."}
         \ee
   \ee
 \ee
\]
Here, the following instance of $\mi{PackM}$ is used. 
\[
\bb
 \key{instance}~\mi{Pack}~\gamma~(\mi{Loc}~\gamma)~\key{where} \\
 \quad \mi{new}~x = \mi{Loc}~x~\mi{Nothing} \\
 \key{instance}~\mi{PackM}~\gamma~(\mi{Loc}~\gamma)~(\mi{W}~[\mi{Result}~(\mi{Loc}~\gamma)])~\key{where}\\
 \quad \mi{liftO}~\mi{p}~x = 
     \key{do}~\bbt
      \mi{tell}~[\mi{Result}~p'~x~(p'~x)]\\
      \mi{return}~(p'~x)
     \ee\\
     \qquad \key{where}~p' = p \circ \mi{map}~\mi{body}
\ee 
\]
%
%\todo{From here}
We used the auxiliary functions 
$\mi{assignIDs}$, $\mi{matchViews}$, $\mi{checkHistory}$ and $\mi{update}$
in the definition of $\mi{bwd}$.
The following are the types and the roles of the functions. 
\begin{itemize}
 \item $\mi{assignIDs} :: \mi{Tree}~\alpha \to \mi{Tree}~(\mi{Loc}~\alpha)$
   assigns different natural numbers to nodes in an input tree. For example, 
   for an input $\mi{Node}~\texttt{"a"}~[\mi{Node}~\texttt{"b"}~[], \mi{Node}~\texttt{"c"}~[]]$, $\mi{assignIDs}$ returns the tree 
   $\mi{Node}~(\mi{Loc}~\texttt{"a"}\ (\mi{Just}~1))\ \allowbreak[\mi{Node}~(\mi{Loc}~\texttt{"b"}~(\mi{Just}~2))~[], \mi{Node}\ (\mi{Loc}\ \texttt{"c"}\ (\mi{Just}~3))~[]]$.
 \item $\mi{matchViews} :: \mi{Eq}~\beta \Rightarrow \mi{Tree}~\beta \to \mi{Tree}~(\mi{Loc}~\beta) \to \mi{IntMap}~\beta$ compares two views and returns a mapping from the changed positions to the changed values.
   For example, let $v = \mi{Node}~\texttt{"a"}~[\mi{Node}~\texttt{"B"}~[], \mi{Node}~\texttt{"c"}~[]]$ and $\mi{xv} = \mi{Node}~(\mi{Loc}~\texttt{"a"}~(\mi{Just}~1))~[\mi{Node}~(\mi{Loc}~\texttt{"b"}~(\mi{Just}~2))~[], \mi{Node}~(\mi{Loc}~\texttt{"c"}~(\mi{Just}~3))~[]]$, $\mi{matchViews}~v~\mi{xv}$ returns a mapping from $2$ to $\texttt{"B"}$.
 \item $\mi{checkHistory} :: \mi{Eq}~\alpha \Rightarrow (\alpha \to \alpha) \to [\mi{Result}~\alpha] \to \mi{Bool}$ checks whether the input updates represented by $\alpha \to \alpha$ does not change the observation history or not. 
 \item $\mi{update} :: \mi{IntMap}~\alpha \to (\mi{Loc}~\alpha) \to (\mi{Loc}~\alpha)$ performs the input updates.
\end{itemize}

To describe the properties of the auxiliary functions, we define a notion of
\emph{location-consistent}. First, we introduce some notations. We write $\mi{elems}$ for a (non-Haskell) function that returns all the elements in a tree. 
Then, we define the notion of consistent view. 
\begin{definition}[Location-Consistency]
A tree $v :: \mi{Tree}~(\mi{Loc}~\alpha)$ is location-consistent if 
there are no two elements $(\mi{Loc}~a~(\mi{Just}~i), (\mi{Loc}~b~(\mi{Just}~j)) \in \mi{elems}~v$ such that $i = j$ but $a \not\texteq b$.
\end{definition}

We are not interested in concrete definitions of the auxiliary functions, while
we use the following properties to prove the correctness of our 
bidirectionalization.
\begin{itemize}
 \item $\mi{assignIDs}~s$ is location-consistent.
 \item $\mi{fmap}~\mi{body}~(\mi{assignIDs}~\mi{s}) = \mi{s}$.
 \item $\mi{update}~\mi{IntMap.empty}~x = x$. %\todo{Can we remove it?}
 \item $\mi{fmap}~(\mi{body} \circ \mi{update}~\mi{upd})~\mi{xview} = v$
    if $\mi{upd} = \mi{matchViews}~\mi{xview}~v$ and $\mi{xview}$ is location consistent.
 \item  
     $\mi{matchViews}~\mi{xview}~v = \mi{IntMap.empty}$
   if $\mi{fmap}~\mi{body}~\mi{xview} = v$ and $\mi{xview}$ is location-consistent. 
 \item $\mi{checkHistory}~\mi{upd}~[] = \mi{True}$.
 \item $\mi{checkHistory}~\mi{upd}~(w_1 \APPEND w_2) = \mi{checkHistory}~\mi{upd}~w_1 \mathbin{\texttt{\&\&}} \mi{checkHistory}~\mi{upd}~w_2$.
 \item $p~(\mi{map}~u~x) = p~x$
    if $\mi{checkHistory}~u~[\mi{Result}~p~x~(p~x)] = \mi{True}$.
 \item $\mi{checkHistory}~\mi{IntMap.empty}~[\mi{Result}~p~x~(p~x)] = \mi{True}$.
 \item $\mi{update}~\mi{upd}~(\mi{new}~x) = \mi{new}~x$
\end{itemize}


\section{Correctness}
In this section, we prove the correctness of our bidirectionalization.
That is, we prove the following two laws:
\[
  \forall s,v.~ \mi{bwd}~h~s~(\mi{fwd}~h~s) = s \tag{\textsc{GetPut}}
  \label{eq:get-put}
\]
\[
\forall s,s',v.~ \mi{bwd}~h~s~v = s' \Rightarrow \mi{fwd}~h~s' = v \tag{\textsc{PutGet}}
 \label{eq:put-get}
\]
Roughly speaking, \ref{eq:get-put} says that no update is propagated if there is no updates on the view, and \ref{eq:put-get} says that the updates on the view are preserved after update reflection as long as the reflection succeeds. 


Similar to the previous work, our correctness proof is also based on the free theorem~\cite{Wadler89}. More concretely, we base ourselves on the version of the free theorem that concerns type classes~\cite{Voigtlander09ft}.


\subsection{Free Theorem}
Following~\cite{Voigtlander09ft}, we introduce several notations and
definitions.  We write $\mathcal{R} : A \leftrightarrow B$ when
$\mathcal{R}$ is a relation on $A \times B$.
\begin{itemize}
\item For a base type $b$, we write $b$ for the relation that relates 
  identical elements of type $b$. 

%The relation $()$ is a relation on types $()$ that relates $()$ and $()$.
 \item For relations $\mathcal{R}$ and $\mathcal{S}$, we
   write $\mathcal{R} \to \mathcal{S}$ for 
   the set $\set{(f,g) \mid \forall (x,y) \in \mathcal{R}, (f~x, g~y) \in \mathcal{S}}$.
 \item Assume that types $\tau$ and $\tau'$ contain at most one free variable $\alpha$. Let $\mathcal{F}$ be a function that maps a relation on $\mathcal{R}: \sigma \leftrightarrow \sigma'$ to $\mathcal{F}~\mathcal{R}: \tau[\sigma/\alpha] \leftrightarrow \tau'[\sigma'/\alpha]$. 
Then, we write $\forall \mathcal{R}.\mathcal{F}~\mathcal{R}$ for the set
$\set{ (u,v) \mid \forall \sigma,\sigma', \mathcal{R} : \sigma \leftrightarrow \sigma'. (u,v) \in \mathcal{F}~\mathcal{R} }$.
\end{itemize} 

\begin{definition}[Relational Action~\cite{Voigtlander09ft}]
For type constructor $\kappa_1$ and $\kappa_2$, $F$ is called a 
\emph{relational action} between $\kappa_1$ and $\kappa_2$, denoted by $\mathcal{F} : \kappa_1 \leftrightarrow \kappa_2$, if 
$\mathcal{F}$ can map any relation $\mathcal{R} : \tau_1 \leftrightarrow \tau_2$ for every closed type $\tau_1$ and $\tau_2$ to $\mathcal{F}~\mathcal{R} : \kappa_1 ~\tau_1 \leftrightarrow \kappa_2 ~\tau_2$.
\qed \end{definition}

%% \begin{definition}[\mi{Monad}-Action~\cite{Voigtlander09ft}]
%% For type constructors $\kappa_1$ and $\kappa_2$ are $\mi{Monad}$, if we
%% call a relation action $F$ a \emph{$\mi{Monad}$}-action if both of the following 
%% conditions hold. 
%% \begin{itemize}
%%  \item $(\mi{return}_{\kappa_1}, \mi{return}_{\kappa_2}) \in 
%%         \forall R.R \to F~R$,
%%  \item $(\BIND_{\kappa_1}, \BIND_{\kappa_2}) \in 
%%    \forall R,S. F~R \to ((R \to F~S) \to F~S)$.
%% \end{itemize}
%% \end{definition}

%% Similarly to $\mi{Monad}$-action~\cite{Voigtlander09ft}, 
%% we define $\mi{WeakWriter}$-action as follows.
%% \begin{definition}[$\mi{WeakWriter}$-Action]
%% For pairs of types and type constructors $(\tau_1,\kappa_1)$ and 
%% $(\tau_2,\kappa_2)$ that are both $\mi{WeakWriter}$ instances,
%% we call a pair $(\mathcal{T} : \tau_1 \leftrightarrow \tau_2,  \mathcal{F} : \kappa \leftrightarrow \kappa_2)$ a $\mi{WeakWriter}$-action 
%% if the pair satisfies the following conditions. 
%% \begin{itemize}
%%   \item $(\mi{return}_{\kappa_1}, \mi{return}_{\kappa_2}) \in 
%%          \forall \mathcal{R}.~\mathcal{R} \to \mathcal{F}~\mathcal{R}$,
%%   \item $(\BIND_{\kappa_1}, \BIND_{\kappa_2}) \in 
%%     \forall \mathcal{R},\mathcal{S}.~ \mathcal{F}~\mathcal{R} \to ((\mathcal{R} \to \mathcal{F}~\mathcal{S}) \to \mathcal{F}~\mathcal{S})$, 
%% \item $(\mi{tell}_{\kappa_1}, \mi{tell}_{\kappa_2}) \in \mathcal{T} \to \mathcal{F}~()$. \qed
%% \end{itemize}
%% \end{definition}

%% \begin{definition}[$\mi{Monad}$-Action]
%% For type constructors $\kappa_1$ and 
%% $\kappa_2$ that are both $\mi{Monad}$ instances,
%% we call a relational action 
%% $\mathcal{F} : \kappa \leftrightarrow \kappa_2)$ a $\mi{Monad}$-action 
%% if it satisfies the following conditions. 
%% \begin{itemize}
%%   \item $(\mi{return}_{\kappa_1}, \mi{return}_{\kappa_2}) \in 
%%          \forall \mathcal{R}.~\mathcal{R} \to \mathcal{F}~\mathcal{R}$, and
%%   \item $(\BIND_{\kappa_1}, \BIND_{\kappa_2}) \in 
%%     \forall \mathcal{R},\mathcal{S}.~ \mathcal{F}~\mathcal{R} \to ((\mathcal{R} \to \mathcal{F}~\mathcal{S}) \to \mathcal{F}~\mathcal{S})$. \qed
%% \end{itemize}
%% \end{definition}



Then, let us focus on a function with type 
\[
\forall \alpha \mu. (\mi{PackM}~L~\alpha~\mu) \Rightarrow 
 \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha)
\]
for some label type $L$.
Following~\cite{Voigtlander09ft}, we have a following free theorem for the datatype.
\begin{theorem}[Free Theorem for View Function]
Let $L$ be a type. 
Let $(\tau_1,\kappa_1)$ and $(\tau_2,\kappa_2)$ are pairs of types and type constructors satisfying:
\begin{itemize}
% \item $(\eta_1,\kappa_1)$ and $(\eta_2,\kappa_2)$ are instances of $\mi{WeakWriter}$ (and thus, $\kappa_1$ and $\kappa_2$ are instances of $\mi{Monad}$s), 
 \item $\kappa_1$ and $\kappa_2$ are instances of $\mi{Monad}$, 
 \item $(L,\tau_1, \kappa_1)$ and $(L,\tau_2, \kappa_2)$ are instances of $\mi{Pack}$, and 
\end{itemize}
Let $\mathcal{L}$ is a relation $\mathcal{L} : L \BETWEEN L$.
Suppose $\mathcal{U} : \tau_1 \BETWEEN \tau_2$
%, $\mathcal{T} : \eta_1 \BETWEEN \eta_2$,  
and $\mathcal{F} : \kappa_1 \BETWEEN \kappa_2$ are
respectively a relation and a relational action, satisfying:
\begin{itemize}%
 %%  \item $(\mi{return}_{\kappa_1}, \mi{return}_{\kappa_2}) \in 
 %%         \forall R.R \to F~R$,
 %%  \item $(\BIND_{\kappa_1}, \BIND_{\kappa_2}) \in 
 %%    \forall R,S. F~R \to ((R \to F~S) \to F~S)$, 
 %% \item $(\mi{tell}_{\tau_1,\kappa_1},\mi{tell}_{\tau_2,\kappa_2}) \in U \to F~()$,
% \item $(\mathcal{T},\mathcal{F})$ are $\mi{WeakWriter}$-action, 
% \item $\mathcal{F}$ is a $\mi{Monad}$-action, 
  \item $(\mi{return}_{\kappa_1}, \mi{return}_{\kappa_2}) \in 
         \forall \mathcal{R}.~\mathcal{R} \to \mathcal{F}~\mathcal{R}$, and
  \item $(\BIND_{\kappa_1}, \BIND_{\kappa_2}) \in 
    \forall \mathcal{R},\mathcal{S}.~ \mathcal{F}~\mathcal{R} \to ((\mathcal{R} \to \mathcal{F}~\mathcal{S}) \to \mathcal{F}~\mathcal{S})$.
 \item $(\mi{new}_{\tau_1},\mi{new}_{\tau_2}) \in \mathcal{L} \to \mathcal{U}$,
 \item $(\mi{liftO}_{L,\tau_1,\mu_1,\sigma_1},\mi{liftO}_{L,\tau_2,\mu_2,\sigma_2}) \in ([\mathcal{L}] \to \mathcal{S}) \to [\mathcal{U}] \to \mathcal{F}~\mathcal{S}$
   for all $\mathcal{S} :: \sigma_1 \BETWEEN \sigma_2$ satisfying 
   $((\texteq)_{\sigma_1},(\texteq)_{\sigma_2}) \in \mathcal{S} \to \mathcal{S} \to \mi{Bool}$.
\end{itemize}
Then, for a function $f$ of type 
\[
\forall \alpha \mu. (\mi{PackM}~L~\alpha~\mu) \Rightarrow 
 \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha)
\]
we have $(f_{\tau_1,\kappa_1},f_{\tau_2,\kappa_2}) \in \mi{Tree}~\mathcal{U} \to \mathcal{F}~(\mi{Tree}~\mathcal{U})$.\qed
\label{thm:ft}
\end{theorem}


\subsection{Preservation of Location Consistency}
Beforehand the proofs, we prove the following lemma to use the property of $\mi{matchViews}$.
\begin{lemma}[Location-Consistency of $\mi{xview}$]
Suppose that $h$ has type 
\(
\forall \alpha \mu. (\mi{PackM}~L~\alpha~\mu) \Rightarrow 
 \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha)
\)
and 
$(\mi{xview},\dontcare) = \mi{runWriter}~(\mi{h}_{\mi{Loc}~\alpha,\mi{Writer}~[\mi{Result}~(\mi{Loc}~\alpha)]}~(\mi{assignIDs}~s))$ for a source $s$. Then, $\mi{xview}$ is consistent. 
\label{lemma:xview}
\end{lemma}

\begin{proof}
Let $s$ be a source and $E$ is the set $\mi{elem}~(\mi{assignIDs}~s)$.
Then, it is worth nothing that we have that $v$ is location-consistent 
if, all the elements $e$ in $\mi{elems}~v$ of the form of $e = \mi{Loc}~\dontcare~(\mi{Just}~\dontcare)$ are in $E$. 
We use the free theorem on $h$. More concretely, we take 
$\mathcal{U}$ and $\mathcal{F}$ as below.
\[
\bb
  \mathcal{U} &=& \set{ (\mi{Loc}~x~(\mi{Just}~i),\mi{Loc}~x~(\mi{Just}~i)) 
    \mid 
      (\mi{Loc}~x~(\mi{Just}~i) \in E}\\
  \mathcal{F}~\mathcal{R} &=& \set{ (W~(x,\dontcare),W~(y,\dontcare)) \mid (x,y) \in \mathcal{R}}
\ee
\]
Note that, by this definition, $\mi{Tree}~\mathcal{U}$ is diagonal
relation, and $v$ such that $(v,v) \in \mi{Tree}~\mathcal{U}$ is
location-consistent.  Then, if we prove that $\mathcal{U}$ and
$\mathcal{F}$ satisfy the conditions, we have $(h,h) \in
\mi{Tree}~\mathcal{U} \to \mathcal{F}~(\mi{Tree}~\mathcal{U})$. Since
$(\mi{assignIDs}~s, \mi{assignIDs}) \in \mi{Tree}~\mathcal{U}$, we
have $(\mi{xview}, \mi{xview}) \in \mi{Tree}~\mathcal{U}$. Thus, $\mi{xview}$ 
is location consistent. 

Then, our obligation is to check the condition to use the free theorem. 
We omit the proof because it is straightforward for $\mathcal{U}$ and $\mathcal{F}$.
\end{proof}

\subsection{Proof of \ref{eq:get-put}}

The overall structure of our \ref{eq:get-put} proof is as follows. 
\begin{align*}
  & \mi{bwd}~h~s~(\mi{fwd}~h~s) \\
= & ~\{ \mbox{ Unfolding $\mi{bwd}$ } \}\\
  & \key{if}~ \mi{checkHistory}~\mi{upd}~\mi{hist}~\key{then}~ \mi{fmap}~(\mi{body} \circ \mi{update}~\mi{upd})~\mi{xsrc}~\key{else}~\dots \\
= & ~\{ 
%\mbox{ $\mi{upd} = I.\mi{empty}$ and $\mi{checkHistory}~I.\mi{empty}~\mi{mist} = \mi{True}$ --- we will prove it in the following } 
    \mbox{ (*) --- see below }\}\\
  & \key{if}~ \mi{checkHistory}~\mi{IntMap.empty}~\mi{hist}~\key{then}~ \mi{fmap}~(\mi{body} \circ \mi{update}~\mi{IntMap.empty})~\mi{xsrc}~\key{else}~\dots \\
= & ~\{ \mbox{ Property of $\mi{update}$ } \}\\
  & \mi{fmap}~(\mi{body} \circ \mi{id})~\mi{xsrc}\\
= & ~\{ \mbox{ Property of $\mi{assignIDs}$ } \}\\
  & s 
\end{align*}

At (*), we use the two properties
$\mi{upd} = \mi{IntMap.empty}$ and $\mi{checkHistory}~\mi{IntMap.empty}~\mi{hist} = \mi{True}$. To show them, it suffices to show the following lemma.
\begin{lemma}
Let $\mi{xsrc}$ be $\mi{assignIDs}~s$.
Suppose we have $(\mi{xview},\mi{hist}) = \mi{runWriter}~(h~\mi{xsrc})$ 
and $\mi{Identity}~\mi{v} = h~s$.
Then, we have $\mi{fmap}~\mi{body}~\mi{xview} = \mi{view}$ and 
$\mi{checkHistory}~\mi{IntMap.empty}~\mi{hist} = \mi{True}$.
\end{lemma}

\begin{proof}
In the proof, for simplicity, 
%% we write $I$ for $\mi{Identity}$ and 
%% $\mi{W}$ for $\mi{WriterT}~(\mi{Identity}~x)$. Note that 
%% $\mi{Writer}~\eta~\alpha$ is a synonym for $\mi{WriterT}~(\mi{Identity}~(\alpha,\eta)$ and $\mi{runWriter}$ is defined by $\mi{runWriter}~(\mi{WriterT}~(\mi{Identity}~x)) = x$. Also,
 we write $m_1$ for a monad $I$ and 
$\mi{m_2}$ for a monad $W~[\mi{Result}~(\mi{Loc}~L)]$.
In addition, we write $t_1$ and $t_2$ for $\mi{L}$ and $\mi{Loc}~\mi{L}$, respectively.

Let $\mathcal{L} :: L \BETWEEN L$ be a relation $\mathcal{L} = \set{ (l,l) \mid l :: L }$.
Let $\mathcal{U} :: t_1 \BETWEEN t_2$ and $\mathcal{F} :: m_1 \BETWEEN m_2$ be a relation and a relational action defined by:
\[
\bb
 %% \mathcal{T}   &=& \set{ (\mi{ObsEq}~x_1~y_1~b, \mi{ObsEq}~x_2~y_2~b) \mid 
 %%                   (x_1,x_2),(y_1,y_2) \in \mathcal{U}, b = (x_1 \texteq y_1) = (x_2 \texteq y_2) } \\
 \mathcal{U}   &=& \set{ (x,y) \mid (x,\mi{body}~y) \in \mathcal{L} }\\
 \mathcal{F}~\mathcal{R} &=& 
   \set{ (I~x,W~(y,w)) \mid (x,y) \in \mathcal{R} \wedge 
                            \mi{checkHistory}~\mi{IntMap.empty}~w = \mi{True}}
%% \left\{ (s,t) \,\left|\, \bb (x,y) \in \mathcal{R} \wedge \mi{checkHistory}~\mi{IntMap.empty}~w = \mi{True}\\ \mbox{ where } x = \mi{runIdentity}~s, (x,w) = \mi{runWriter}~t\ee\right\}\right.\\
\ee
\]
Then, if we can prove that $\mathcal{L}$, $\mathcal{U}$
and $\mathcal{F}$ satisfy the conditions to apply
Theorem~\ref{thm:ft}, we have $(h,h) \in \mathcal{R} \to \mathcal{F}~\mathcal{R}$, \ie, for any
$x,y$ satisfying $x = \mi{fmap}~\mi{body}~y$, we have $v =
\mi{fmap}~\mi{body}~u$ and $\mi{checkHistory}~\mi{IntMap.empty}~w = \mi{True}$ where $v = \mi{runIdentity}~(h~x)$ and
$\mi{runWriter}~(u,w) = h~y$. Taking $x = s$ and $y =
\mi{assignID}~s$, the proof is done.

Thus, our obligation is to prove $\mathcal{L}$, $\mathcal{U}$
and $\mathcal{F}$ satisfy the conditions to apply
Theorem~\ref{thm:ft}. 

\paragraph{Case: $\mi{return}$.} 
We prove $(\mi{return}_{m_1}~x, \mi{return}_{m_2}~y) \in \mathcal{F}~\mathcal{R}$ for any $(x,y) \in \mathcal{R}$. Unfolding the definition, we get $\mi{return}_{m_1}~x = \mi{I}~x$ and $\mi{return}_{m_2}~y = \mi{W}~(y,[])$. 
Since we have $\mi{checkHistory}~\mi{upd}~[] = \mi{True}$, we have
$(\mi{return}_{m_1}~x, \mi{return}_{m_2}~y) \in \mathcal{F}~\mathcal{R}$.

\paragraph{Case: $\BIND$.}
We prove that $(\BIND_{m_1}, \BIND_{m_2}) 
\in \forall \mathcal{R},\mathcal{S}. \mathcal{F} \mathcal{R} \to (\mathcal{R} \to \mathcal{F}~\mathcal{S}) \to \mathcal{F}~\mathcal{S}$.
It suffices to show that, for $\mi{I}~x$ and $\mi{W}~(y,w)$ such that $(x,y) \in \mathcal{R}$ and $\mi{checkHistory}~\mi{IntMap.empty}~w = \mi{True}$, and for functions $f$ and $g$ such that $(f~a,g~b) \in \mathcal{F}~\mathcal{S}$ for any $(a,b) \in \mathcal{R}$ then $(\mi{I}~x \BIND f, \mi{W}~(y,w) \BIND g) \in \mathcal{F}~\mathcal{S}$ holds. This is obvious from the definition of $\BIND$ and distributivity of $\mi{checkHistory}~\mi{upd}$.

%% \paragraph{Case: $\mi{tell}$.} We prove that 
%% $(\mi{tell}~x, \mi{tell}~y) \in \mathcal{F}~()$ holds for any $(x,y) \in \mathcal{T}$. This is proved by using the definition of $\mi{checkHistory}$.

\paragraph{Case: $\mi{new}$.} Obvious. 

\paragraph{Case: $\mi{liftO}$.}
We prove that $(\mi{liftO}_{L,t_1,m_1,r_1}, \mi{liftO}_{L,t_2,m_2,r_2}) \in 
([L] \to \mathcal{S}) \to ([\mathcal{U}] \to \mathcal{F}~\mathcal{S})$ for any $\mathcal{S} : r_1 \BETWEEN r_2$ satisfying $((\texteq)_{r_1}, (\texteq)_{r_2}) \in \mathcal{S}$.
Let $(p_1,p_2)$ are any functions satisfying $(p,p') \in [\mathcal{L}] \to \mathcal{S}$ and $x_1 :: [t_1]$ and $x_2 :: [t_2]$ are lists satisfying $(x,y) \in [\mathcal{U}]$. Then we prove $(\mi{liftO}~p_1~x_1, \mi{liftO}~p_2~x_2) \in \mathcal{F}~\mathcal{S}$. By definition, we have $\mi{liftO}~p_1~x_2 = I~(p_1~x_1)$
 and $\mi{liftO}~p_2~x_2 = W~(p_2'~x_2, [\mi{Result}~p_2'~x_2~(p_2'~x_2)])$ where 
$p' = p \circ \mi{map}~\mi{body}$. Since we have $(x_1,x_2) \in [\mathcal{U}]$ 
and thus $(x_1, \mi{map}~\mi{body}~x_2) \in [\mathcal{L}]$, we have $(p_1~x_1,p'_2~x_2) \in \mathcal{S}$ from $(p_1,p_2) \in [\mathcal{L}] \to \mathcal{S}$.
By definition of $\mi{checkHistory}$, it is clear that $\mi{checkHistory}~\mi{IntMap.empty}~[\mi{Result}~p_2'~x_2~(p_2'~x_2)] = \mi{True}$.
Thus, we have $(\mi{liftO}~p_1~x_1, \mi{liftO}~p_2~x_2) \in \mathcal{F}~\mathcal{S}$.

%% \paragraph{Case: $\mi{eq}$.} 
%% %% For this case, we use the fact that 
%% %% $\mi{eq}_{t_1}$ and $\mi{eq}_{t_2}$ are polymorphic functions of types
%% %% $\forall \mu. \mi{WeakWriter}~t_1~\mu \Rightarrow t_1 \to t_1 \to \mu~\mi{Bool}$ 
%% %% and $\forall \mu. \mi{WeakWriter}~t_1~\mu \Rightarrow t_2 \to t_2 \to \mu~\mi{Bool}$.
%% %% Then, we can say $(\mi{eq}_{t_i,n_i}, \mi{eq}_{t_i,n_i'}) \in t_i \to t_i \to G~t_i$ for any relation action $G$ such that $(t_i,n_i)$ and $(t_i,n'_i)$ are both $\mi{WeakWriter}$-action. 
%% We prove that $(\mi{eq}_{t_1,m_1}~a_1~b_1, \mi{eq}_{t_2,m_2}~a_2~b_2)$
%% are related by $\mathcal{F}~\mi{Bool}$ if $(a_1,a_2) \in \mathcal{U}$
%% and $(b_1,b_2) \in \mathcal{U}$. 
%% Unfolding the definition, we have $\mi{eq}_{t_1,m_1}~a_1~b_1 = I~(a_1 \texteq b_1)$
%%  and $\mi{eq}_{t_2,m_2}~a_2~b_2 = W~
%% (\mi{body}~a_2 \texteq
%% \mi{body}~b_2)~
%% [\mi{Obs}~a_2~b_2~(\mi{body}~a_2 \texteq
%% \mi{body}~b_2)]$. 
%% From $(a_1,a_2) \in \mathcal{U}$ and
%% $(b_1,b_2) \in \mathcal{U}$, we have $(a_1 \texteq b_1) = (\mi{body}~a_2
%% \texteq \mi{body}~b_2)$.
%% By definition of $\mi{checkHistory}$, we have 
%% $\mi{checkHistory}~\mi{IntMap.empty}~[\mi{Obs}~a_2~b_2~(\mi{body}~a_2 \texteq
%% \mi{body}~b_2)] = \mi{True}$.
%% Thus, we have $(\mi{eq}_{t_1,m_1}~a_1~b_1, \mi{eq}_{t_2,m_2}~a_2~b_2) \in \mathcal{F}~\mi{Bool}$.
\end{proof}

\subsection{Proof of \ref{eq:put-get}}

The proof is a bit more complicated but has similar structure.
The overall structure of our \ref{eq:put-get} proof is as follows. 

\begin{align*}
  & \mi{fwd}~h~(\mi{bwd}~h~s~v) \mbox{ if $\mi{bwd}~h~s~v$ succeeds } \\
= & ~\{ \mbox{ Unfolding $\mi{bwd}$ and $\mi{bwd}$ succeeds } \}\\
  & \mi{fwd}~h~(\mi{fmap}~(\mi{body} \circ \mi{update}~\mi{upd})~\mi{xsrc})\\
= & ~\{ \mbox{ (*) --- see the following } \}\\
  & \mi{fmap}~(\mi{body} \circ (\mi{update}~\mi{upd}))~\mi{xview}\\
= & ~\{ \mbox{ Property of $\mi{matchView}$ } \} \\
  & v 
\end{align*}

At (*), we used the following lemma.
\begin{lemma}
Suppose: 
\begin{itemize}
\item  $\mi{checkHistory}~\mi{upd}~\mi{hist} = \mi{True}$
\item $\mi{I}~\mi{v'} = h~s'$
\item  $\mi{xsrc} = \mi{assignIDs}~s$ 
\item  $\mi{s'} = \mi{fmap}~(\mi{body} \circ \mi{update}~\mi{upd})~\mi{xsrc}$ 
\item  $\mi{W}~(\mi{xview},\mi{hist}) = h~\mi{xsrc}$ 
\end{itemize}
Then, 
\[
  v' = \mi{fmap}~(\mi{body} \circ \mi{update}~\mi{upd})~\mi{xview}
\]
holds.
\end{lemma}

\begin{proof}
To simplify the notation, we write 
$m_1$ and $m_2$ for $\mi{I}$ and $\mi{W}~[\mi{Result}~(\mi{Loc}~\mi{L})]$
 respectively, and $t_1$ and $t_2$ for $\mi{L}$ and $\mi{Loc}~\mi{L}$, respectively.
Let $\mathcal{L} :: L \BETWEEN L$ be a relation $\mathcal{L} = \set{ (l,l) \mid l :: L }$.
Let $\mathcal{U} :: t_1 \BETWEEN t_2$ and $\mathcal{F} :: m_1 \BETWEEN m_2$ be a relation, a relation and a relational action defined by:
\[
\bb
 %% \mathcal{T}   &=& \set{ (\mi{ObsEq}~x_1~y_1~b_1,\mi{ObsEq}~x_2~y_2~b_2) \mid  (x_1,x_2) \in \mathcal{U}, (x_2,y_2) \in \mathcal{U} }\\
 \mathcal{U}   &=& \set{ (x,y) \mid x = \mi{body}~(\mi{update}~\mi{upd}~y) }\\
 \mathcal{F}~\mathcal{R} &=& \set{ (\mi{I}~x,\mi{W}~(y,w)) \mid 
 \mi{checkHistory}~(\mi{update}~\mi{upd})~w \Rightarrow (x,y) \in \mathcal{R} }\\
\ee
\]
Then, if we can prove that $\mathcal{L}$, %$\mathcal{T}$, 
$\mathcal{U}$ and $\mathcal{F}$ satisfies the conditions to apply 
Theorem~\ref{thm:ft}, we can prove the lemma straightforwardly. 

\paragraph{Case: $\mi{return}$.} We prove $(\mi{return}_{m_1}~x,\mi{return}_{m_2}~y) \in \mathcal{F}~\mathcal{R}$, provided that $(x,y) \in \mathcal{R}$.
Unfolding the definition of $\mi{return}$, what we have to prove now is 
$(\mi{I}~x,\mi{W}~(y,[])) \in \mathcal{F}~\mathcal{R}$. This clearly holds 
from the definition of $\mathcal{F}$.

\paragraph{Case: $\BIND$.}
We prove that $(\BIND_{m_1}, \BIND_{m_2}) \in \forall
\mathcal{R},\mathcal{S}. \mathcal{F}~\mathcal{R} \to (\mathcal{R} \to
\mathcal{F}~\mathcal{S}) \to \mathcal{F}~\mathcal{S}$.  It suffices to
show that $(\mi{I}~x \BIND f, \mi{W}~(y,w) \BIND g) \in
\mathcal{F}~\mathcal{S}$, provided that $(x,y) \in R$ and $f$ and $g$
are functions that satisfy $(f~a, g~b) \in \mathcal{F}~\mathcal{S}$
for any $(a,b) \in \mathcal{R}$. Let us write $f~x$ and $g~y$ as
$\mi{I}~x'$ and $\mi{W}~(y',w')$ respectively; this is possible because $W$ and $I$ are defined by $\key{newtype}$. 
Then, $\mi{I}~x \BIND f$ can be written as $\mi{I}~x'$, and 
$\mi{W}~(y,w) \BIND g$ can be written as $\mi{W}~(y',w \APPEND w')$.  
Suppose that we have
$\mi{checkHistory}~\mi{upd}~(w \APPEND w') = \mi{True}$. Then, from
the distributivity of $\mi{checkHistory}~\mi{upd}$, we have
$\mi{checkHistory}~\mi{upd}~w = \mi{True}$ and
$\mi{checkHistory}~\mi{upd}~w' = \mi{True}$. From the former fact, we
obtain $(x,y) \in \mathcal{R}$. From this result and the latter fact,
we have $(x',y') \in \mathcal{S}$.  Thus, from the definition of
$\mathcal{F}$, we have $(\mi{I}~x \BIND f, \mi{W}~(y,w) \BIND g) \in
\mathcal{F}~\mathcal{S}$.

%% \paragraph{Case: $\mi{tell}$.}
%% We prove that $(\mi{tell}~x, \mi{tell}~y) \in \mathcal{F}~()$
%% for any $(x,y) \in \mathcal{T}$. This is trivial because $((),()) \in ()$.

\paragraph{Case: $\mi{new}$.}
We prove that $(\mi{new}_{L,t_1}~x,\mi{new}_{L,t_2}~x) \in \mathcal{U}$.
From the fact 
 $\mi{update}~\mi{upd}~(\mi{new}_{L,t_2}~x) = \mi{new}_{L,t_2}~x$, we
have $\mi{body}~(\mi{update}~\mi{upd}~(\mi{new}_{L,t_2}~x)) = 
\mi{body}~(\mi{new}_{L,t_2}~x) = \mi{body}~(\mi{Loc}~x~\mi{Nothing}) = x = \mi{new}_{L,t_1}~x$, which proves $(\mi{new}_{L,t_1}~x,\mi{new}_{L,t_2}~x) \in \mathcal{U}$.

\paragraph{Case: $\mi{liftO}$.}
We prove that $(\mi{liftO}_{L,t_1,m_1,r_1}, \mi{liftO}_{L,t_2,m_2,r_2}) \in 
([L] \to \mathcal{S}) \to ([\mathcal{U}] \to \mathcal{F}~\mathcal{S})$ for any $\mathcal{S} : r_1 \BETWEEN r_2$ satisfying $((\texteq)_{r_1}, (\texteq)_{r_2}) \in \mathcal{S}$.
Let $(p_1,p_2)$ are any functions satisfying $(p,p') \in [\mathcal{L}] \to \mathcal{S}$ and $x_1 :: [t_1]$ and $x_2 :: [t_2]$ are lists satisfying $(x,y) \in [\mathcal{U}]$. Then we prove $(\mi{liftO}~p_1~x_1, \mi{liftO}~p_2~x_2) \in \mathcal{F}~\mathcal{S}$. By definition, we have $\mi{liftO}~p_1~x_2 = I~(p_1~x_1)$
 and $\mi{liftO}~p_2~x_2 = W~(p_2'~x_2, [\mi{Result}~p_2'~x_2~(p_2'~x_2)])$ where 
$p' = p \circ \mi{map}~\mi{body}$. 
Assume that we have $\mi{checkHistory}~(\mi{update}~\mi{upd})~[\mi{Result}~p_2'~x_2~(p_2'~x_2)]$, which implies $p_2'~(\mi{map}~(\mi{update}~\mi{upd})~x_2) = p_2'~x_2$.
Since we have $(x_1,x_2) \in [\mathcal{U}]$ 
and thus $(x_1, \mi{map}~(\mi{body} \circ \mi{update}~\mi{upd})~x_2) \in [\mathcal{L}]$, we have $(p_1~x_1,p'_2~(\mi{map}~(\mi{update}~\mi{upd})~x_2)) \in \mathcal{S}$ from $(p_1,p_2) \in [\mathcal{L}] \to \mathcal{S}$.
Since we have $p_2'~(\mi{map}~(\mi{update}~\mi{upd})~x_2) = p_2'~x_2$, 
we have $(p_1~x_1,p_2'~x_2) \in \mathcal{S}$.
Thus, we have $(\mi{liftO}~p_1~x_1, \mi{liftO}~p_2~x_2) \in \mathcal{F}~\mathcal{S}$.


%% \paragraph{Case: $\mi{eq}$.}
%% We prove that $(\mi{eq}_{t_1,m_1}~a_1~b_1, \mi{eq}_{t_2,m_2}~a_2~b_2)$
%% are related by $\mathcal{F}~\mi{Bool}$ if $(a_1,a_2) \in \mathcal{U}$
%% and $(b_1,b_2) \in \mathcal{U}$.
%% Unfolding the definition, we have $\mi{eq}_{t_1,m_1}~a_1~b_1 = I~(a_1 \texteq b_1)$
%%  and $\mi{eq}_{t_2,m_2}~a_2~b_2 = W~
%% (\mi{body}~a_2 \texteq
%% \mi{body}~b_2)~
%% [\mi{Obs}~a_2~b_2~(\mi{body}~a_2 \texteq
%% \mi{body}~b_2)]$. 
%% Suppose that we have $\mi{checkUpdate}~\mi{upd}~[\mi{Obs}~a_2~b_2~(\mi{body}~a_2 \texteq
%% \mi{body}~b_2)] =\mi{True}$. With the definition of $\mi{checkUpdate}$, 
%% this implies that $(\mi{body}~a_2 \texteq
%% \mi{body}~b_2) = (a_1 \texteq b_1)$. Thus, we have 
%% $(\mi{eq}_{t_1,m_1}~a_1~b_1, \mi{eq}_{t_2,m_2}~a_2~b_2) \in \mathcal{F}~\mi{Bool}$.
\end{proof}

\subsection{Getting Dirty}
Unfortunately, the $\mi{fwd}$ and $\mi{bwd}$ defined so far are unusable in 
Haskell's type system. Even if we prepare a function of type 
$\forall \alpha \mu. (\mi{PackM}~\gamma~\alpha~\mu) \Rightarrow \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\gamma)$ we cannot apply it with $\mi{fwd}$ and $\mi{bwd}$. One reason is that 
because $\gamma$ of $\mi{Pack}~\gamma~\alpha$ does not appear in type 
$\mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha)$ the inference algorithm does not 
correctly pose constraints on $\gamma$ and it does not tell what $\gamma$ is actually used. \todo{I am not sure this is actually the reason why the type inference fails.}

To avoid the situation, one possible solution is to tell the type system that $\gamma$ is uniquely determined from $\alpha$. Fortunately, Haskell provides 
a solution to this situation. We can use functional dependencies. 
Concretely, we declare the class $\mi{Pack}$ as below to indicates that $\gamma$ is determined by $\alpha$.
\[
\bb
 \key{class}~\mi{Pack}~\gamma~\alpha \mid \alpha \to \gamma 
  ~\key{where}~ \dots
\ee
\]
Similarly we add a functional dependency from a monad $\mu$ to an abstracted type $\alpha$ in $\mi{PackM}$. \todo{Is it necessary}
\[
\bb
 \key{class}~\mi{Pack}~\gamma~\alpha \Rightarrow \mi{PackM}~\gamma~\alpha~\mu \mid \mu \to \alpha
  ~\key{where}~ \dots
\ee
\]


However, then the instance $\mi{Pack}~\gamma~\gamma$ violates the functional dependency. One solution is that we remove the instance declaration of $\mi{Pack}~\gamma~\gamma$ and redefine $\mi{fwd}$ as follows. 
\[
\bb
\mi{fwd} :: \mi{Eq}~\gamma \Rightarrow (
 \forall \alpha \eta. (\mi{Pack}~\gamma~\alpha, \mi{EqO}~\alpha~\mu) \Rightarrow 
 \mi{Tree}~\alpha \to \mu~(\mi{Tree}~\alpha))
 \to \mi{Tree}~\gamma \to \mi{Tree}~\gamma\\
\mi{fwd}~h = \lambda s. 
    \key{let}~\mi{I}~v = h~(\mi{assignIDs}~s)~\key{in}~\mi{fmap}~\mi{body}~v 
\ee
\]
The definition is safe. We can show that the definition does not change the semantics as in the similar to way to the lemma used to prove \ref{eq:get-put}.


\bibliographystyle{abbrv}
\bibliography{main}


\end{document}
